"use strict";(self.webpackChunkresilient_react_docs=self.webpackChunkresilient_react_docs||[]).push([[210],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return h}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(t),h=o,f=p["".concat(l,".").concat(h)]||p[h]||d[h]||i;return t?r.createElement(f,a(a({ref:n},u),{},{components:t})):r.createElement(f,a({ref:n},u))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=t[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},1279:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var r=t(7462),o=t(3366),i=(t(7294),t(3905)),a=["components"],s={sidebar_position:3},l="Dependency Hell",c={unversionedId:"dependency-hell",id:"dependency-hell",title:"Dependency Hell",description:"Our enemies",source:"@site/docs/dependency-hell.mdx",sourceDirName:".",slug:"/dependency-hell",permalink:"/resilient-react/docs/dependency-hell",editUrl:"https://github.com/nervestaple/resilient-react/tree/main/docs/dependency-hell.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Single Source of Truth",permalink:"/resilient-react/docs/single-source-of-truth"},next:{title:"How to think about forms",permalink:"/resilient-react/docs/how-to-think-about-forms"}},u=[{value:"Our enemies",id:"our-enemies",children:[],level:2},{value:"Why can&#39;t I just ignore deps if it feels necessary? Why are you being so annoying?!",id:"why-cant-i-just-ignore-deps-if-it-feels-necessary-why-are-you-being-so-annoying",children:[{value:"Opening your third eye: thinking beyond &quot;render ordering&quot;",id:"opening-your-third-eye-thinking-beyond-render-ordering",children:[],level:3},{value:"When dependencies change but effects aren&#39;t run",id:"when-dependencies-change-but-effects-arent-run",children:[],level:3}],level:2}],d={toc:u};function p(e){var n=e.components,t=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dependency-hell"},"Dependency Hell"),(0,i.kt)("h2",{id:"our-enemies"},"Our enemies"),(0,i.kt)("p",null,"Our codebase is under threat. Our enemies are hiding, lying in wait everywhere. They must be destroyed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"useEffect(() => {\n  /* ... code code code ... */\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, []);\n// This effect should just run on mount!!! Don't add any dependencies!\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"useEffect(() => {\n  doSomethingWith(thingA, thingB);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n}, [thingA]);\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'const myValue = useRef("something");\nuseEffect(() => {\n  doSomethingWith(myValue.current);\n}, []);\n')),(0,i.kt)("h2",{id:"why-cant-i-just-ignore-deps-if-it-feels-necessary-why-are-you-being-so-annoying"},"Why can't I just ignore deps if it feels necessary? Why are you being so annoying?!"),(0,i.kt)("p",null,"Ok, ok. Imagine we're fetching data from an API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'async function mockFetchNotes(apiKey) {\n  return new Promise((resolve) =>\n    setTimeout(\n      () =>\n        resolve([\n          { id: 1, text: "buy shoes" },\n          { id: 2, text: "eat food" },\n        ]),\n      500\n    )\n  );\n}\n\nfunction useFakeContext() {\n  return "api-key";\n}\n\nfunction NoteList() {\n  const apiKey = useFakeContext();\n  const [notes, setNotes] = useState(null);\n\n  useEffect(() => {\n    async function fetchNotes() {\n      const n = await mockFetchNotes(apiKey);\n      setNotes(n);\n    }\n    fetchNotes();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  if (!notes) {\n    return "Loading...";\n  }\n\n  return (\n    <ul>\n      {notes.map((n) => (\n        <li key={n.id}>{n.text}</li>\n      ))}\n    </ul>\n  );\n}\n\nrender(\n  <ComponentWithRefresh>\n    <NoteList />\n  </ComponentWithRefresh>\n);\n')),(0,i.kt)("p",null,"It's a simple, familiar situation. We need to display a list of notes.\nThose notes originate from an API. Fetching that data is a 'side effect', so we do it inside\n",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect"),"."),(0,i.kt)("p",null,"Whoever wrote this probably said:\n",(0,i.kt)("em",{parentName:"p"},'"Fetching data should be done on mount, so the useEffect dependency array should be ',(0,i.kt)("inlineCode",{parentName:"em"},"[]"),'.\nThe linter complains about this, so we just need to tell it to shut up."')),(0,i.kt)("h3",{id:"opening-your-third-eye-thinking-beyond-render-ordering"},'Opening your third eye: thinking beyond "render ordering"'),(0,i.kt)("p",null,"Unfortunately, thinking about 'when we're mounted' and 'which render we're on' has already trapped us in the wrong mental model.\nA better mental model is treating renders as fully independent calls of the component function, unrelated to 'mounting'.\nEach render has data (from state and props) that's in scope, that you transform and use to generate a render result.\nThere were (probably) renders before this one, and there will (probably) be renders after.\nThe best part -- it doesn't really matter as long as we generally treat renders as independent, repeatable events that can happen at any time."),(0,i.kt)("p",null,'In general, React always runs effects after each render, then optimizes by skipping certain effects if it deems it necessary.\nIn fact, in "StrictMode", React intentionally runs all effects twice!\nIf your effects can\'t safely be run twice, your code will be brittle!'),(0,i.kt)("p",null,"Ensuring effects run -- whenever necessary and with current versions of their dependent data -- is ",(0,i.kt)("em",{parentName:"p"},"much more")," important than trying to control ",(0,i.kt)("em",{parentName:"p"},"how often")," effects will run."),(0,i.kt)("h3",{id:"when-dependencies-change-but-effects-arent-run"},"When dependencies change but effects aren't run"),(0,i.kt)("p",null,"Let's return to the above example. imagine somewhere else in the app, changes ",(0,i.kt)("inlineCode",{parentName:"p"},"apiKey")," from a test key to a production key.\nAlready, our assumption that 'this needs to run once, on mount' has been broken. Our component will not ",(0,i.kt)("em",{parentName:"p"},"react")," to this change."),(0,i.kt)("p",null,"Additionally, our ",(0,i.kt)("inlineCode",{parentName:"p"},"eslint-ignore")," statement is also hurting any future developers who work on this code --\npreventing them from being notified if they extend this code and add more implicit dependencies!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'const apiData = [\n  { id: 1, text: "buy shoes" },\n  { id: 2, text: "eat food", isImportant: true },\n];\n\nasync function mockFetchNotes(apiKey, onlyImportant) {\n  return new Promise((resolve) =>\n    setTimeout(() => {\n      if (onlyImportant) {\n        resolve(apiData.filter((n) => n.isImportant));\n      } else {\n        resolve(apiData);\n      }\n    }, 500)\n  );\n}\n\nfunction useFakeContext() {\n  return "api-key";\n}\n\nfunction NoteList() {\n  const apiKey = useFakeContext();\n  const [notes, setNotes] = useState(null);\n  const [onlyImportant, setOnlyImportant] = useState(false);\n\n  useEffect(() => {\n    async function fetchNotes() {\n      const n = await mockFetchNotes(apiKey, onlyImportant);\n      setNotes(n);\n    }\n    fetchNotes();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return (\n    <>\n      {notes && (\n        <ul>\n          {notes.map((n) => (\n            <li key={n.id}>{n.text}</li>\n          ))}\n        </ul>\n      )}\n      <div>\n        Important notes only:{" "}\n        <input\n          type="checkbox"\n          checked={onlyImportant}\n          onChange={() => setOnlyImportant((i) => !i)}\n        />\n      </div>\n    </>\n  );\n}\n\nrender(\n  <ComponentWithRefresh>\n    <NoteList />\n  </ComponentWithRefresh>\n);\n')),(0,i.kt)("p",null,"It obviously doesn't work. When ",(0,i.kt)("inlineCode",{parentName:"p"},"isImportant")," changes, the effect is not re-run, and the data is stale.\n",(0,i.kt)("em",{parentName:"p"},"(of course, we could also just filter this on the client side with so little data.\nimagine we're fetching a long list of data that needs to be filtered on the server)")),(0,i.kt)("p",null,"Try removing the eslint-ignore line and giving the effect all its required dependencies.\nWe're fetching from the API more often -- but that's exactly what we need to do. There's no way around it!\nWe can't will ourselves into a world where it ",(0,i.kt)("em",{parentName:"p"},"doesn't")," depend on its dependencies. We can't lie to React!"))}p.isMDXComponent=!0}}]);