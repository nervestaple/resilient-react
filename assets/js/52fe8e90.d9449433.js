"use strict";(self.webpackChunkresilient_react_docs=self.webpackChunkresilient_react_docs||[]).push([[346],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return c}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=u(t),c=r,h=d["".concat(l,".").concat(c)]||d[c]||p[c]||o;return t?a.createElement(h,i(i({ref:n},m),{},{components:t})):a.createElement(h,i({ref:n},m))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8203:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return m},default:function(){return d}});var a=t(7462),r=t(3366),o=(t(7294),t(3905)),i=["components"],s={sidebar_position:4},l="How To Think About Forms",u={unversionedId:"how-to-think-about-forms",id:"how-to-think-about-forms",title:"How To Think About Forms",description:"What is a form?",source:"@site/docs/how-to-think-about-forms.mdx",sourceDirName:".",slug:"/how-to-think-about-forms",permalink:"/resilient-react/docs/how-to-think-about-forms",editUrl:"https://github.com/nervestaple/resilient-react/tree/main/docs/how-to-think-about-forms.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Dependency Hell",permalink:"/resilient-react/docs/dependency-hell"}},m=[{value:"What is a form?",id:"what-is-a-form",children:[],level:2},{value:"Unify form state",id:"unify-form-state",children:[],level:2},{value:"Complex multi-component forms",id:"complex-multi-component-forms",children:[],level:2},{value:"Initial form state",id:"initial-form-state",children:[],level:2}],p={toc:m};function d(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-to-think-about-forms"},"How To Think About Forms"),(0,o.kt)("h2",{id:"what-is-a-form"},"What is a form?"),(0,o.kt)("p",null,"A set of related user inputs that are meant to be persisted together."),(0,o.kt)("p",null,"Most app code (or at least, the most complicated portions of app code) is forms!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function UserForm() {\n  const [formState, setFormState] = useState({ name: null, age: null });\n  const [submitState, setSubmitState] = useState("initial");\n\n  const apiSubmit = useSubmit(); // mocked function for this demo\n  async function handleSubmit(e) {\n    e.preventDefault();\n\n    setSubmitState("loading");\n    await apiSubmit(formState);\n    setSubmitState("success");\n  }\n\n  function handleChange(update) {\n    setFormState((oldFormState) => ({ ...oldFormState, ...update }));\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <span style={{ color: "gray", fontStyle: "italic" }}>\n        {submitState === "loading" && "sending..."}\n        {submitState === "success" && "submitted!"}\n      </span>\n      <div>\n        Name:{" "}\n        <input\n          type="text"\n          value={formState.name}\n          onChange={(e) => handleChange({ name: e.target.value })}\n        />\n      </div>\n      <div>\n        Age:{" "}\n        <input\n          type="number"\n          value={formState.age}\n          onChange={(e) => handleChange({ age: e.target.value })}\n        />\n      </div>\n      <button type="submit">Submit</button>\n    </form>\n  );\n}\n\nrender(\n  <SubmitProvider>\n    <UserForm />\n  </SubmitProvider>\n);\n')),(0,o.kt)("h2",{id:"unify-form-state"},"Unify form state"),(0,o.kt)("p",null,"In the previous example, there are two pieces of state: ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"age"),".\nHowever -- they're both going to end up being submitted as part of the same 'blob' to the API.\nThere's generally not a compelling reason to keep them in separate state fields.\nWhy not just maintain them in their desired structure at all times?"),(0,o.kt)("p",null,"Our form state is centralized, and only has one root function that all changes are passed through (",(0,o.kt)("inlineCode",{parentName:"p"},"onChange"),").\nIt's not critical that form onChange functions use the pattern above -- where updates are merged in -- but it makes things pretty easy!"),(0,o.kt)("p",null,'One might say "well, we have so many inputs, and our form logic is so complicated -- there\'s no way it could fit into this model!"'),(0,o.kt)("p",null,"One would be wrong! There's nothing keeping you from splitting your form across many deeply-nested subcomponents.\nThe only 'contract' every child needs to adhere to is:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"receive a ",(0,o.kt)("inlineCode",{parentName:"li"},"value")," prop that contains the formState"),(0,o.kt)("li",{parentName:"ol"},"receive an ",(0,o.kt)("inlineCode",{parentName:"li"},"onChange")," prop that receives updates")),(0,o.kt)("p",null,"Or something similar."),(0,o.kt)("h2",{id:"complex-multi-component-forms"},"Complex multi-component forms"),(0,o.kt)("p",null,"In the following example, we add additional fields split across several tabs.\nThere's more code, but not really any additional complexity.\nWe don't need to keep re-inventing ways to store and change data."),(0,o.kt)("p",null,"Additionally, we give ",(0,o.kt)("inlineCode",{parentName:"p"},"<UserForm />")," a ",(0,o.kt)("inlineCode",{parentName:"p"},"userData={}")," prop that will be used later."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'const steps = [Step1, Step2, Step3];\nfunction UserForm({ userData }) {\n  const [tab, setTab] = useState(0);\n\n  const [formState, setFormState] = React.useState(\n    userData || {\n      name: null,\n      age: null,\n      favoriteColor: null,\n      isHungry: false,\n      isThirsty: false,\n    }\n  );\n\n  function handleChange(update) {\n    setFormState((oldFormState) => ({ ...oldFormState, ...update }));\n  }\n\n  const apiSubmit = useSubmit(); // mocked function for this demo\n  async function handleSubmit(e) {\n    e.preventDefault();\n    await apiSubmit(formState);\n  }\n\n  const Step = steps[tab];\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        {steps.map((s, i) => (\n          <button\n            type="button"\n            onClick={() => setTab(i)}\n            style={{\n              margin: 2,\n              backgroundColor: i === tab ? "white" : "lightgray",\n              fontWeight: i === tab ? "bold" : null,\n            }}\n          >\n            {i + 1}\n          </button>\n        ))}\n        <div>\n          <button type="submit">Submit</button>\n        </div>\n      </div>\n      <hr />\n      <Step value={formState} onChange={handleChange} />\n    </form>\n  );\n}\n\nfunction Step1({ value, onChange }) {\n  return (\n    <div>\n      <div>\n        Name:{" "}\n        <input\n          type="text"\n          value={value.name}\n          onChange={(e) => onChange({ name: e.target.value })}\n        />\n      </div>\n      <div>\n        Age:{" "}\n        <input\n          type="number"\n          value={value.age}\n          onChange={(e) => onChange({ name: e.target.age })}\n        />\n      </div>\n    </div>\n  );\n}\n\nfunction Step2({ value, onChange }) {\n  return (\n    <div>\n      <div>\n        Favorite Color:{" "}\n        <input\n          type="text"\n          value={value.favoriteColor}\n          onChange={(e) => onChange({ favoriteColor: e.target.value })}\n        />\n        <div\n          style={{\n            width: 100,\n            height: 100,\n            backgroundColor: value.favoriteColor,\n            margin: 4,\n          }}\n        />\n      </div>\n    </div>\n  );\n}\n\nfunction Step3({ value, onChange }) {\n  return (\n    <div>\n      <div>\n        Are you hungry?{" "}\n        <input\n          type="checkbox"\n          checked={value.isHungry}\n          onChange={(e) => onChange({ isHungry: e.target.checked })}\n        />\n      </div>\n      <div>\n        Are you thirsty?{" "}\n        <input\n          type="checkbox"\n          checked={value.isThirsty}\n          onChange={(e) => onChange({ isThirsty: e.target.checked })}\n        />\n      </div>\n    </div>\n  );\n}\n\nrender(\n  <SubmitProvider>\n    <UserForm />\n  </SubmitProvider>\n);\n')),(0,o.kt)("h2",{id:"initial-form-state"},"Initial form state"),(0,o.kt)("p",null,"In many cases, forms get their initial state from an API.\nThe user usually wants to modify this state, then re-persist the modified version."),(0,o.kt)("p",null,"Developers supplying and synchronizing the initial state for forms are often sources of the improper use of ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect"),"."),(0,o.kt)("p",null,"In the example below, we wrap the form we've been building in the previous examples with a component that fetches the form's initial data from the API."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function FormContainer() {\n  const [userData, setUserData] = useState(null);\n  const [userId, setUserId] = useState(1);\n  useEffect(() => {\n    async function fetchUserData() {\n      const data = await apiFetchUserDataById(userId); // mocked\n      setUserData(data);\n    }\n    fetchUserData();\n  }, [userId]);\n\n  return (\n    <div>\n      <h3>User Form for User ID: {userId}</h3>\n      <div onChange={(e) => setUserId(parseInt(e.target.value))}>\n        <input type="radio" value={1} name="userId" checked={userId === 1} />{" "}\n        UserID 1\n        <input\n          type="radio"\n          value={2}\n          name="userId"\n          checked={userId === 2}\n        /> UserID 2\n      </div>\n      <hr />\n      <UserForm key={userData ? userData.id : null} userData={userData} />\n    </div>\n  );\n}\n\nrender(\n  <SubmitProvider>\n    <FormContainer />\n  </SubmitProvider>\n);\n')),(0,o.kt)("p",null,"A less-known feature of the 'key' prop (outside of element arrays) is to completely reset a component.\nBy keying our form on a unique ID identifying the state that 'hydrates' our form,\nwe don't need to do ",(0,o.kt)("em",{parentName:"p"},"any")," synchronization work to actively reset the form. It just works!"),(0,o.kt)("p",null,"As an alternative to the approach using ",(0,o.kt)("inlineCode",{parentName:"p"},"key"),", we could 'lift up' the ",(0,o.kt)("inlineCode",{parentName:"p"},"formState")," field into this component,\nand copy ",(0,o.kt)("inlineCode",{parentName:"p"},"userData")," into it alongside the ",(0,o.kt)("inlineCode",{parentName:"p"},"setUserData")," call."))}d.isMDXComponent=!0}}]);