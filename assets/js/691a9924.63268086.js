"use strict";(self.webpackChunkresilient_react_docs=self.webpackChunkresilient_react_docs||[]).push([[621],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(n),h=i,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||r;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2264:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),s=["components"],o={sidebar_position:2},l="Single Source of Truth",c={unversionedId:"single-source-of-truth",id:"single-source-of-truth",title:"Single Source of Truth",description:"If an app contains data, that data should be minimally represented.",source:"@site/docs/single-source-of-truth.mdx",sourceDirName:".",slug:"/single-source-of-truth",permalink:"/resilient-react/docs/single-source-of-truth",editUrl:"https://github.com/nervestaple/resilient-react/tree/main/docs/single-source-of-truth.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Motivation",permalink:"/resilient-react/docs/intro"},next:{title:"Dependency Hell",permalink:"/resilient-react/docs/dependency-hell"}},p=[{value:"Minimally represented?",id:"minimally-represented",children:[],level:2},{value:"&quot;The Bug&quot;",id:"the-bug",children:[],level:2},{value:"Looking at Two Fixes: Bad and Worse",id:"looking-at-two-fixes-bad-and-worse",children:[{value:"BAD:",id:"bad",children:[],level:3},{value:"WORSE:",id:"worse",children:[],level:3},{value:"BEST!",id:"best",children:[],level:3}],level:2}],d={toc:p};function u(e){var t=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"single-source-of-truth"},"Single Source of Truth"),(0,r.kt)("p",null,"If an app contains data, that data should be ",(0,r.kt)("em",{parentName:"p"},"minimally represented"),"."),(0,r.kt)("p",null,"Put another way, every 'unique' piece of data should have exactly one place it's stored and updated.\nAll downstream uses of that data should be passed down, transformed into derived values, but never duplicated in another state field."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"(note: this doesn't mean you're not allowed to store 'working copies' of user-editable data in state fields)")),(0,r.kt)("h2",{id:"minimally-represented"},"Minimally represented?"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'"Take all the data needed to render this application.\nWhat is the minimal amount of state we can use to represent this data?"')),(0,r.kt)("p",null,"This doesn't necessarily mean we need to just mindlessly combine state fields into compound objects (though often that's the right choice).\nPrimarily, the goal is to identify and eliminate situations where data stored in state essentially duplicates data stored in other state, even if in a transformed form."),(0,r.kt)("p",null,"Consider this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function TextTransformer() {\n  const [text, setText] = useState("Test");\n  const [capitalizedText, setCapitalizedText] = useState(text.toUpperCase());\n  const [isCaps, setIsCaps] = useState(false);\n\n  return (\n    <div>\n      <input\n        value={text}\n        onChange={(e) => {\n          setText(e.target.value);\n          setCapitalizedText(e.target.value.toUpperCase());\n        }}\n      />{" "}\n      Capitalize?{" "}\n      <input\n        type="checkbox"\n        onChange={() => setIsCaps((c) => !c)}\n        checked={isCaps}\n      />\n      <hr />\n      <h3>{isCaps ? capitalizedText : text}</h3>\n    </div>\n  );\n}\nrender(<TextTransformer />);\n')),(0,r.kt)("p",null,"The issue with this example (duplicated representations of data across multiple state fields) might be obvious --\nbut even then, it seems relatively harmless.\nAfter all -- it works! What's the big deal?"),(0,r.kt)("h2",{id:"the-bug"},'"The Bug"'),(0,r.kt)("p",null,"Unfortunately, the decision made to represent the app's state in this way is insidious,\nand its implications might not become apparent until later on in development."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function TextTransformer() {\n  const [text, setText] = useState("Test");\n  const [capitalizedText, setCapitalizedText] = useState(text.toUpperCase());\n  const [isCaps, setIsCaps] = useState(false);\n\n  return (\n    <div style={{ display: "flex", flexDirection: "column" }}>\n      <input\n        value={text}\n        onChange={(e) => {\n          setText(e.target.value);\n          setCapitalizedText(e.target.value.toUpperCase());\n        }}\n      />\n      <label>\n        Capitalize?{" "}\n        <input\n          type="checkbox"\n          onChange={() => setIsCaps((c) => !c)}\n          checked={isCaps}\n        />\n      </label>\n      <button onClick={() => setText("")}>Reset</button>\n      <hr />\n      <h3>{isCaps ? capitalizedText : text}</h3>\n    </div>\n  );\n}\nrender(<TextTransformer />);\n')),(0,r.kt)("p",null,"The bug is a bit contrived (forgetting to resetting ",(0,r.kt)("inlineCode",{parentName:"p"},"capitalizedText")," in the reset button), but it represents a real, continuing threat to our code.\nOnce data becomes duplicated in this way, it becomes much harder to keep track of all the ways we need to change it."),(0,r.kt)("h2",{id:"looking-at-two-fixes-bad-and-worse"},"Looking at Two Fixes: Bad and Worse"),(0,r.kt)("p",null,"Let's put aside the best way to fix this issue. What are some common ways developers will choose to fix this?"),(0,r.kt)("h3",{id:"bad"},"BAD:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'<button\n  onClick={() => {\n    setText("");\n    setCapitalizedText("");\n  }}\n>\n  Reset\n</button>\n')),(0,r.kt)("p",null,"This fixes the issue. The state is back in sync. But -- whenever this logic is modified or extended in the future,\nwe still have to keep track and synchronize these two state fields."),(0,r.kt)("h3",{id:"worse"},"WORSE:"),(0,r.kt)("p",null,"With long components and complex webs of state and business logic,\nit can feel easy to reach for ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffect")," as a way to ensure ",(0,r.kt)("inlineCode",{parentName:"p"},"text")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"capitalizedText")," are synchronized:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function TextTransformer() {\n  const [text, setText] = useState("Test");\n  const [capitalizedText, setCapitalizedText] = useState(text.toUpperCase());\n  const [isCaps, setIsCaps] = useState(false);\n\n  useEffect(() => {\n    setCapitalizedText(text.toUpperCase());\n  }, [text]);\n\n  return (\n    <div style={{ display: "flex", flexDirection: "column" }}>\n      <input\n        value={text}\n        onChange={(e) => {\n          setText(e.target.value);\n          setCapitalizedText(e.target.value.toUpperCase());\n        }}\n      />\n      <label>\n        Capitalize?{" "}\n        <input\n          type="checkbox"\n          onChange={() => setIsCaps((c) => !c)}\n          checked={isCaps}\n        />\n      </label>\n      <button onClick={() => setText("")}>Reset</button>\n      <hr />\n      <h3>{isCaps ? capitalizedText : text}</h3>\n    </div>\n  );\n}\nrender(<TextTransformer />);\n')),(0,r.kt)("p",null,"This also fixes the bug, but at the cost of extra renders -- and, more importantly,\nadding unpredictable side-effects to changing state. In this example, it becomes much more difficult to reason about\nexactly what the state of ",(0,r.kt)("inlineCode",{parentName:"p"},"text")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"capitalizedText")," is during each render. Now -- imagine 10 more state fields,\neach with their own ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffects")," synchronizing them to each other."),(0,r.kt)("h3",{id:"best"},"BEST!"),(0,r.kt)("p",null,"Hopefully I've demonstrated that 'working' code is not necessarily correct or advisable.\nFocusing on eliminating the 'code smell' present in the previous example (",(0,r.kt)("inlineCode",{parentName:"p"},"setState")," inside ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffect"),")\ncan lead us in the direction of optimal code."),(0,r.kt)("p",null,"Let's ask, for real:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'"Take all the data needed to render this application.\nWhat is the minimal amount of state we can use to represent this data?"')),(0,r.kt)("p",null,"The main realization necessary is that ",(0,r.kt)("inlineCode",{parentName:"p"},"capitalizedText")," is just duplicated state.\nIn every render, it can be entirely derived from the current state of ",(0,r.kt)("inlineCode",{parentName:"p"},"text"),".\nWe don't need the extra state field, nor the effect required to synchronize it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function TextTransformer() {\n  const [text, setText] = useState("Test");\n  const [isCaps, setIsCaps] = useState(false);\n\n  const capitalizedText = text.toUpperCase();\n\n  return (\n    <div style={{ display: "flex", flexDirection: "column" }}>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      <label>\n        Capitalize?{" "}\n        <input\n          type="checkbox"\n          onChange={() => setIsCaps((c) => !c)}\n          checked={isCaps}\n        />\n      </label>\n      <button onClick={() => setText("")}>Reset</button>\n      <hr />\n      <h3>{isCaps ? capitalizedText : text}</h3>\n    </div>\n  );\n}\nrender(<TextTransformer />);\n')),(0,r.kt)("p",null,"The solution for 'derived state' -- state that can be entirely derived from other available data --\nis ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),"! Just assign a variable that's calculated on every render. In this simple example, we could even have just\nput ",(0,r.kt)("inlineCode",{parentName:"p"},"text.toUpperCase()")," inline in the JSX."),(0,r.kt)("p",null,"Like I said, this is a contrived example,\nbut it represents a simplified version of a lot of the problems facing our codebase!"),(0,r.kt)("p",null,"Imagine growing the original example with derived state into a much more complex app. Once ",(0,r.kt)("inlineCode",{parentName:"p"},"capitalizedText"),' is introduced,\nand our application becomes more dependent on it, it might be hard to imagine removing it.\nAfter all, all this code -- states, useEffects, etc, is "doing important stuff"!\nIt becomes difficult to remove any single piece of it without breaking a complex web of\nstate, effects, and synchronized state.'))}u.isMDXComponent=!0}}]);