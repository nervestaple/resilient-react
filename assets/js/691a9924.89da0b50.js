"use strict";(self.webpackChunkresilient_react_docs=self.webpackChunkresilient_react_docs||[]).push([[621],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),h=i,f=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return n?a.createElement(f,s(s({ref:t},p),{},{components:n})):a.createElement(f,s({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2264:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),s=["components"],o={sidebar_position:2},l="Single Source of Truth",c={unversionedId:"single-source-of-truth",id:"single-source-of-truth",title:"Single Source of Truth",description:"If an app contains data, that data should be minimally represented.",source:"@site/docs/single-source-of-truth.mdx",sourceDirName:".",slug:"/single-source-of-truth",permalink:"/resilient-react/docs/single-source-of-truth",editUrl:"https://github.com/nervestaple/resilient-react/tree/main/docs/single-source-of-truth.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Motivation",permalink:"/resilient-react/docs/intro"}},p=[{value:"Minimally represented?",id:"minimally-represented",children:[],level:2},{value:"&quot;The Bug&quot;",id:"the-bug",children:[],level:2},{value:"Looking at Two Fixes: Bad and Worse",id:"looking-at-two-fixes-bad-and-worse",children:[{value:"BAD:",id:"bad",children:[],level:3},{value:"WORSE:",id:"worse",children:[],level:3},{value:"BEST!",id:"best",children:[],level:3}],level:2}],u={toc:p};function d(e){var t=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"single-source-of-truth"},"Single Source of Truth"),(0,r.kt)("p",null,"If an app contains data, that data should be ",(0,r.kt)("em",{parentName:"p"},"minimally represented"),"."),(0,r.kt)("h2",{id:"minimally-represented"},"Minimally represented?"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'"Take all the data needed to render this application.\nWhat is the least amount of state we can use to represent this data?"')),(0,r.kt)("p",null,"Note -- this doesn't necessarily mean we need to just mindlessly combine state fields into compound objects (though often that's the right choice).\nPrimarily, the goal is to identify and eliminate situations where data stored in state essentially duplicates data stored in other state, even if in a transformed form."),(0,r.kt)("p",null,"Consider this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function TextTransformer() {\n  const [text, setText] = useState("Test");\n  const [capitalizedText, setCapitalizedText] = useState(text.toUpperCase());\n  const [isCaps, setIsCaps] = useState(false);\n\n  return (\n    <div>\n      <input\n        value={text}\n        onChange={(e) => {\n          setText(e.target.value);\n          setCapitalizedText(e.target.value.toUpperCase());\n        }}\n      />{" "}\n      Capitalize?{" "}\n      <input\n        type="checkbox"\n        onChange={() => setIsCaps((c) => !c)}\n        checked={isCaps}\n      />\n      <hr />\n      <h3>{isCaps ? capitalizedText : text}</h3>\n    </div>\n  );\n}\nrender(<TextTransformer />);\n')),(0,r.kt)("p",null,"The issue with this example (duplicated representations of data across multiple state fields) might be obvious --\nbut even then, it seems relatively harmless.\nAfter all -- it works! What's the big deal?"),(0,r.kt)("h2",{id:"the-bug"},'"The Bug"'),(0,r.kt)("p",null,"Unfortunately, the decision made to represent the app's state in this way is insidious,\nand its implications might not become apparent until later on in development."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function TextTransformer() {\n  const [text, setText] = useState("Test");\n  const [capitalizedText, setCapitalizedText] = useState(text.toUpperCase());\n  const [isCaps, setIsCaps] = useState(false);\n\n  return (\n    <div style={{ display: "flex", flexDirection: "column" }}>\n      <input\n        value={text}\n        onChange={(e) => {\n          setText(e.target.value);\n          setCapitalizedText(e.target.value.toUpperCase());\n        }}\n      />\n      <label>\n        Capitalize?{" "}\n        <input\n          type="checkbox"\n          onChange={() => setIsCaps((c) => !c)}\n          checked={isCaps}\n        />\n      </label>\n      <button onClick={() => setText("")}>Reset</button>\n      <hr />\n      <h3>{isCaps ? capitalizedText : text}</h3>\n    </div>\n  );\n}\nrender(<TextTransformer />);\n')),(0,r.kt)("p",null,"The bug is a bit contrived (forgetting to resetting ",(0,r.kt)("inlineCode",{parentName:"p"},"capitalizedText")," in the reset button), but it represents a real threat to our code.\nOnce data becomes duplicated in this way, it becomes much harder to keep track of all the ways we need to change it."),(0,r.kt)("h2",{id:"looking-at-two-fixes-bad-and-worse"},"Looking at Two Fixes: Bad and Worse"),(0,r.kt)("p",null,"Let's put aside the best way to fix this issue. What are some common ways developers will choose to fix this?"),(0,r.kt)("h3",{id:"bad"},"BAD:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'<button\n  onClick={() => {\n    setText("");\n    setCapitalizedText("");\n  }}\n>\n  Reset\n</button>\n')),(0,r.kt)("p",null,"This fixes the issue. The state is back in sync. But -- whenever this logic is modified or extended in the future,\nwe still have to keep track and synchronize these two state fields."),(0,r.kt)("h3",{id:"worse"},"WORSE:"),(0,r.kt)("p",null,"But, with long components and complex webs of state and business logic,\nit can feel easy to reach ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffect"),' as a way to "cut through the BS":'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function TextTransformer() {\n  const [text, setText] = useState("Test");\n  const [capitalizedText, setCapitalizedText] = useState(text.toUpperCase());\n  const [isCaps, setIsCaps] = useState(false);\n\n  useEffect(() => {\n    setCapitalizedText(text.toUpperCase());\n  }, [text]);\n\n  return (\n    <div style={{ display: "flex", flexDirection: "column" }}>\n      <input\n        value={text}\n        onChange={(e) => {\n          setText(e.target.value);\n          setCapitalizedText(e.target.value.toUpperCase());\n        }}\n      />\n      <label>\n        Capitalize?{" "}\n        <input\n          type="checkbox"\n          onChange={() => setIsCaps((c) => !c)}\n          checked={isCaps}\n        />\n      </label>\n      <button onClick={() => setText("")}>Reset</button>\n      <hr />\n      <h3>{isCaps ? capitalizedText : text}</h3>\n    </div>\n  );\n}\nrender(<TextTransformer />);\n')),(0,r.kt)("p",null,"This also fixes it, but at the cost of extra renders -- and, more importantly,\nadding unpredictable side-effects to changing state. In this example, it becomes much more difficult to reason about\nexactly what the state of ",(0,r.kt)("inlineCode",{parentName:"p"},"text")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"capitalizedText")," is during each render. Now -- imagine 10 more state fields,\neach with their own ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffects")," synchronizing them to each other."),(0,r.kt)("h3",{id:"best"},"BEST!"),(0,r.kt)("p",null,"Hopefully I've demonstrated that 'working' code is not necessarily correct or advisable.\nThe 'code smell' present in the previous example -- of ",(0,r.kt)("inlineCode",{parentName:"p"},"setState")," inside ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffect")," --\ncan lead us in the direction of optimal code."),(0,r.kt)("p",null,"Let's ask, for real:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'"Take all the data needed to render this application.\nWhat is the least amount of state we can use to represent this data?"')),(0,r.kt)("p",null,"The main realization necessary is that ",(0,r.kt)("inlineCode",{parentName:"p"},"capitalizedText")," is just duplicated state.\nIn every render, it can be entirely derived from the current state of ",(0,r.kt)("inlineCode",{parentName:"p"},"text"),".\nWe don't need the extra state field, nor the effect required to synchronize it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function TextTransformer() {\n  const [text, setText] = useState("Test");\n  const [isCaps, setIsCaps] = useState(false);\n\n  return (\n    <div style={{ display: "flex", flexDirection: "column" }}>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      <label>\n        Capitalize?{" "}\n        <input\n          type="checkbox"\n          onChange={() => setIsCaps((c) => !c)}\n          checked={isCaps}\n        />\n      </label>\n      <button onClick={() => setText("")}>Reset</button>\n      <hr />\n      <h3>{isCaps ? capitalizedText : text}</h3>\n    </div>\n  );\n}\nrender(<TextTransformer />);\n')),(0,r.kt)("p",null,"Imagining growing this example into a much more complex app -- once ",(0,r.kt)("inlineCode",{parentName:"p"},"capitalizedText"),' is introduced, and our application becomes more dependent on it,\nit can be hard to imagine removing it. After all, all this code is "doing important stuff"!\nIt becomes difficult to remove any single piece of it without breaking a complex web of state, effects, and synchronized state.'))}d.isMDXComponent=!0}}]);